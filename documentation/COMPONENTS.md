# Project JAKE - Components Specification

## Purpose
Create a comprehensive AI chatting API for custom character (JAKE/자캐) interactions with:
- Automatic character generation with rich details
- Quest-based progression system
- Relationship development through conversations
- Long-term memory with semantic search
- Dynamic character evolution

## System Requirements
- ✅ Automatically generate character details from minimal input
- ✅ Quest system for structured interactions
- ✅ Relationship stages gated by advancement quests
- ✅ Semantic long-term memory using vector database
- ✅ Dynamic character profile updates based on conversations
- ✅ Rich conversational outputs (dialogue, actions, emotions, context)

## Architecture Stack

- **Backend**: FastAPI (Python 3.9+)
- **LLM Framework**: LangChain + LangGraph
- **Database**: SQLAlchemy (SQLite/PostgreSQL)
- **Vector Store**: ChromaDB
- **LLM Provider**: OpenAI GPT-4/GPT-4o
- **Orchestration**: LangGraph state machine

---

## Core Components

### 1. JAKECreator
**Location**: `src/agents/jake_creator.py`

**Purpose**: Generate complete character profiles from basic user input.

**Core Methods**:

#### `_design_worldview(character_basics: Dict) → str`
Generates the character's worldview and setting.

**Input**:
```python
{
    "name": str,          # Character name
    "age": str,           # Character age
    "occupation": str,    # Character occupation
    "additional_info": str # Optional extra details
}
```

**Output**: String (300-500 words) describing worldview, setting, era, and context.

**Prompt**: `src/prompts/creator_prompts.py::WORLDVIEW_SYSTEM`

---

#### `_design_details(str_worldview: str, character_basics: Dict) → Dict`
Generates detailed character traits based on worldview.

**Input**:
- `str_worldview`: Worldview generated by `_design_worldview`
- `character_basics`: Same as above

**Output**:
```python
{
    "personality": str,      # Personality traits and temperament
    "character": str,        # Distinctive characteristics and quirks
    "speaking_style": str,   # Speech patterns, tone, vocabulary
    "likes": str,           # Things character enjoys
    "dislikes": str,        # Things character avoids
    "background": str,      # Background story
    "goals": str            # Aspirations and motivations
}
```

**Prompt**: `src/prompts/creator_prompts.py::DETAILS_SYSTEM`

---

#### `create_character(character_basics: Dict) → Dict`
Complete pipeline combining worldview and details.

**Output**:
```python
{
    "basics": {...},           # Original input
    "worldview": str,          # Generated worldview
    "details": {...},          # Generated traits
    "dynamic_profile": ""      # Empty initially, updated during conversations
}
```

**Tech Stack**: LangChain, OpenAI GPT-4o, JsonOutputParser

### 2. JAKEChatter
**Location**: `src/agents/jake_chatter.py`

**Purpose**: Generate rich conversational responses with dialogue, actions, emotions, and affection tracking.

**Core Methods**:

#### `_build_character_context(character_basics, character_details, dynamic_profile) → str`
Builds comprehensive character context string for prompting.

**Returns**: Formatted string with all character information.

---

#### `_chat(query, character_basics, character_details, history, dynamic_profile, current_affection) → Dict`
Generates complete chat response.

**Input**:
- `query`: User's message (str)
- `character_basics`: Basic info dict
- `character_details`: Traits dict from JAKECreator
- `history`: List[Dict] - Previous messages with role/content
- `dynamic_profile`: String with updated traits
- `current_affection`: Int (0-100)

**Output**:
```python
{
    "dialogue": str,           # Character's spoken words
    "action": str,             # Physical actions/expressions (e.g., "*smiles*")
    "situation": str,          # Current scene/situation description
    "background": str,         # Environmental/atmospheric details
    "affection_score": int,    # Updated affection (0-100)
    "affection_change": int,   # Change from previous (-10 to +10)
    "internal_thought": str    # Character's unspoken thoughts
}
```

---

#### `chat(query, character, history, current_affection) → Dict`
Simplified interface wrapping `_chat`.

**Prompt**: `src/prompts/chatter_prompts.py::CHAT_SYSTEM`

**Features**:
- In-character roleplay
- Rich multi-modal output (text, actions, context)
- Dynamic affection scoring
- History-aware responses
- Integrates dynamic profile updates

**Tech Stack**: LangChain, MessagesPlaceholder, JsonOutputParser

### 3. JAKEChecker
**Location**: `src/agents/jake_checker.py`

**Purpose**: Analyze conversation history to validate quest completion.

**Core Methods**:

#### `_format_history(history: List[Dict]) → str`
Formats last 6 messages (3 turns) into readable text.

---

#### `_check_quest(history, dict_quest) → Dict`
Validates regular quest completion.

**Input**:
- `history`: List of conversation messages (last 3 turns)
- `dict_quest`:
```python
{
    "quests": [
        {
            "id": str,
            "title": str,
            "description": str,
            "cleared": int  # 0 or 1
        }
    ]
}
```

**Output**: Same structure with updated `cleared` values (0 or 1).

**Prompt**: `src/prompts/checker_prompts.py::QUEST_CHECK_SYSTEM`

**Quest Types**:
- Conversation quests (ask questions, discuss topics)
- Action quests (perform activities together)
- Relationship quests (build rapport, show interest)

---

#### `_check_advancement_quest(history, dict_quest, current_affection, relationship_stage) → Dict`
Validates advancement quests for relationship progression.

**Additional Inputs**:
- `current_affection`: Int (0-100)
- `relationship_stage`: "stranger" | "acquaintance" | "friend" | "close_friend" | "special"

**Input Quest Structure**:
```python
{
    "quests": [
        {
            "id": str,
            "title": str,
            "description": str,
            "required_affection": int,  # Minimum affection needed
            "cleared": int
        }
    ]
}
```

**Prompt**: `src/prompts/checker_prompts.py::ADVANCEMENT_CHECK_SYSTEM`

**Relationship Stages**:
- stranger (0-20 affection)
- acquaintance (20-40)
- friend (40-60)
- close_friend (60-80)
- special (80-100)

---

#### `check_quests(history, regular_quests, advancement_quests, ...) → Dict`
Combined interface for checking both quest types.

**Returns**:
```python
{
    "regular_quests": {...},      # Updated regular quests
    "advancement_quests": {...}   # Updated advancement quests
}
```

**Tech Stack**: LangChain, JsonOutputParser, GPT-4o (temperature=0 for consistency)

### 4. JAKEDynamicProfiler
**Location**: `src/agents/jake_dynamic_profiler.py`

**Purpose**: Update character profiles dynamically based on conversation events and experiences.

**Example**:
```
Original likes: flowers, chocolate, bookstores
During conversation: Character visits amusement park with user
Updated likes: flowers, chocolate, bookstores, amusement parks
```

**Core Methods**:

#### `_format_history(history, num_turns=3) → str`
Formats recent conversation history.

---

#### `_dynamic_profile(history, character_details, quest_context) → str`
Identifies NEW information to add to character profile.

**Input**:
- `history`: Recent conversation turns
- `character_details`: Original character traits
- `quest_context`: Optional quest information for context

**Output**: String with bullet-pointed additions, or empty string if no updates.

**Looks for**:
1. NEW likes or dislikes discovered
2. NEW experiences or memories created
3. NEW traits or quirks revealed
4. NEW relationships or feelings developed
5. NEW knowledge or interests shown

**Important**: Only returns ADDITIONS, not duplicates of existing profile.

**Prompt**: `src/prompts/profiler_prompts.py::DYNAMIC_PROFILE_SYSTEM`

---

#### `update_profile(character, history, quest_context) → str`
Simplified interface that combines existing and new profile additions.

**Returns**: Updated `dynamic_profile` string combining old + new.

---

#### `should_update(history_length: int) → bool`
Determines if profile update should run based on conversation length.

**Returns**: `True` if `history_length >= 10` turns (per PLAN.md).

**Tech Stack**: LangChain, StrOutputParser, GPT-4o (temperature=0.3)

### 5. JAKESummarizer
**Location**: `src/agents/jake_summarizer.py`

**Purpose**: Extract atomic facts from conversations for long-term memory storage.

**Core Methods**:

#### `_extract_facts(turn: Dict) → str`
Formats a single user-assistant exchange.

---

#### `get_memory(history, character_name) → Dict`
Extracts and categorizes atomic facts from the last conversation turn.

**Input**:
- `history`: List[Dict] of messages (extracts last 2 messages = 1 turn)
- `character_name`: Character's name for context

**Output**:
```python
{
    "facts": [str, ...],                    # General factual statements
    "emotions": [str, ...],                 # Emotional moments/reactions
    "key_events": [str, ...],              # Important events/milestones
    "user_info": [str, ...],               # Info learned about user
    "character_revelations": [str, ...]    # New things about character
}
```

**Example Facts**:
- **facts**: "User prefers coffee over tea", "It's raining outside"
- **emotions**: "Character felt happy when praised"
- **key_events**: "Planned to visit library together"
- **user_info**: "User works as a teacher", "User has a cat named Whiskers"
- **character_revelations**: "Character loves mystery novels"

**Prompt**: `src/prompts/summarizer_prompts.py::MEMORY_SYSTEM`

---

#### `should_run(history_length: int) → bool`
Always returns `True` if `history_length >= 2` (per PLAN.md - runs every turn).

**Tech Stack**: LangChain, JsonOutputParser, GPT-4o-mini (cost-efficient)

---

## Orchestration & Infrastructure

### 6. JAKEOrchestrator
**Location**: `src/agents/jake_orchestrator.py`

**Purpose**: LangGraph-based orchestrator coordinating all JAKE components through a state machine.

**Core Functionality**:

#### State Machine Flow
```
START → Chat → Route based on turn_count
   ├─→ (turns < 3)    → Summarize → END
   ├─→ (3 ≤ turns < 10) → Check Quests → Summarize → END
   └─→ (turns ≥ 10)   → Check Quests → Update Profile → Summarize → END
```

**State Schema**:
```python
class ConversationState(TypedDict):
    # Input
    user_message: str
    character: Dict[str, Any]
    history: List[Dict[str, str]]
    regular_quests: Dict[str, Any]
    advancement_quests: Dict[str, Any]
    current_affection: int
    relationship_stage: str
    turn_count: int
    
    # Output
    response: Dict[str, Any]
    updated_quests: Dict[str, Any]
    updated_dynamic_profile: str
    memories: Dict[str, List[str]]
    updated_affection: int
```

**Core Methods**:

#### `_build_graph() → StateGraph`
Constructs the LangGraph state machine with nodes and conditional edges.

#### `_chat_node(state) → state`
Executes JAKEChatter to generate response.

#### `_check_quests_node(state) → state`
Executes JAKEChecker for quest validation.

#### `_update_profile_node(state) → state`
Executes JAKEDynamicProfiler for profile updates.

#### `_summarize_node(state) → state`
Executes JAKESummarizer for memory extraction.

#### `_route_after_chat(state) → Literal["summarize_only", "check_and_summarize", "full_process"]`
Routes based on turn count (implements PLAN.md logic).

#### `process_message(user_message, character, history, ...) → Dict`
Main entry point for processing a user message through the complete pipeline.

#### `create_character(character_basics) → Dict`
Wrapper for JAKECreator.create_character().

**Tech Stack**: LangGraph StateGraph, all 5 core agents

---

### 7. PromptManager
**Location**: `src/prompts/prompt_manager.py`

**Purpose**: Centralized prompt management system for maintainability and version control.

**Structure**:
```
src/prompts/
├── __init__.py
├── prompt_manager.py          # Central manager
├── creator_prompts.py         # JAKECreator prompts
├── chatter_prompts.py         # JAKEChatter prompts
├── checker_prompts.py         # JAKEChecker prompts
├── profiler_prompts.py        # JAKEDynamicProfiler prompts
└── summarizer_prompts.py      # JAKESummarizer prompts
```

**Available Methods**:
- `get_worldview_prompt()` → ChatPromptTemplate
- `get_details_prompt()` → ChatPromptTemplate
- `get_chat_prompt()` → ChatPromptTemplate
- `get_quest_check_prompt()` → ChatPromptTemplate
- `get_advancement_check_prompt()` → ChatPromptTemplate
- `get_dynamic_profile_prompt()` → ChatPromptTemplate
- `get_memory_extraction_prompt()` → ChatPromptTemplate

**Benefits**:
1. Single source of truth for all prompts
2. Easy prompt updates without code changes
3. Version control for prompt engineering
4. Consistent prompt structure across components
5. Testable prompts

**Tech Stack**: LangChain ChatPromptTemplate, MessagesPlaceholder

---

## Data Layer

### 8. Database Models
**Location**: `src/models/schemas.py`

**Database Tables**:

#### `Character`
Stores character profiles.
```python
id: int (PK)
user_id: str
name, age, occupation: str
additional_info: text
worldview: text
details: JSON  # personality, speaking_style, likes, etc.
dynamic_profile: text
created_at, updated_at: datetime
```

#### `Conversation`
Tracks conversation sessions.
```python
id: int (PK)
character_id: int (FK)
session_id: str (unique)
affection_score: int (default: 50)
relationship_stage: str (default: "stranger")
turn_count: int (default: 0)
created_at, last_interaction: datetime
```

#### `Message`
Stores individual messages.
```python
id: int (PK)
conversation_id: int (FK)
role: str  # "user" or "assistant"
content: text
# For assistant messages:
dialogue, action, situation, background, internal_thought: text
affection_change: int
timestamp: datetime
```

#### `Quest`
Stores quest data.
```python
id: int (PK)
character_id: int (FK)
quest_type: str  # "regular" or "advancement"
title, description: str
required_affection: int (default: 0)
cleared: int (0 or 1)
created_at, cleared_at: datetime
```

#### `Memory`
Stores extracted facts.
```python
id: int (PK)
character_id: int (FK)
conversation_id: int (FK)
category: str  # "fact", "emotion", "key_event", "user_info", "character_revelation"
content: text
embedding: JSON  # Vector embedding
timestamp: datetime
```

**Tech Stack**: SQLAlchemy ORM, SQLite/PostgreSQL

---

### 9. Vector Store
**Location**: `src/utils/vector_store.py`

**Purpose**: Semantic search for long-term memory using vector embeddings.

**Core Methods**:

#### `get_or_create_collection(character_id: int)`
Creates/retrieves ChromaDB collection for a character.
Collection name: `character_{character_id}_memories`

#### `add_memory(character_id, memory_id, content, metadata)`
Embeds and stores a memory fact.
- Generates embedding using OpenAI Embeddings
- Stores in ChromaDB with metadata

#### `search_memories(character_id, query, n_results=5) → List[Dict]`
Semantic search for relevant memories.
- Embeds query
- Searches by cosine similarity
- Returns top N most relevant memories

#### `delete_character_memories(character_id)`
Removes all memories for a character.

**Tech Stack**: ChromaDB, OpenAI Embeddings (text-embedding-ada-002)

---

## API Layer

### 10. FastAPI Application
**Location**: `src/main.py`

**Purpose**: REST API exposing all JAKE functionality.

**Key Endpoints**:

#### Character Management
- `POST /characters` - Create new character
- `GET /characters/{character_id}` - Get character details
- `GET /users/{user_id}/characters` - List user's characters

#### Chat
- `POST /characters/{character_id}/chat` - Chat with character
  - Automatically handles full pipeline
  - Returns dialogue, actions, affection, quest status, memories

#### Quests
- `POST /characters/{character_id}/quests` - Create quest
- `GET /characters/{character_id}/quests` - List all quests

#### Memory
- `GET /characters/{character_id}/memories?query={q}` - Semantic memory search

#### Conversation History
- `GET /conversations/{session_id}` - Get full conversation history

**Features**:
- Session management via `X-Session-Id` header
- Automatic database persistence
- Vector storage integration
- CORS enabled
- Interactive docs at `/docs`

**Tech Stack**: FastAPI, Uvicorn, Pydantic

---

## Complete System Diagram

```
┌─────────────────────────────────────────────────────────┐
│                     FastAPI Server                       │
│                      (src/main.py)                       │
└───────────┬─────────────────────────────────┬───────────┘
            │                                 │
            ▼                                 ▼
    ┌───────────────┐              ┌────────────────────┐
    │ JAKEOrchestrator│              │  Database Layer    │
    │  (LangGraph)   │◄────────────►│  (SQLAlchemy)      │
    └────────┬───────┘              │  - Character       │
             │                      │  - Conversation    │
     ┌───────┴────────┐             │  - Message         │
     │  PromptManager │             │  - Quest           │
     │  (Centralized) │             │  - Memory          │
     └────────────────┘             └────────────────────┘
             │                               │
     ┌───────┴──────────────────┐           │
     │   5 Core Agents          │           │
     │  ┌─────────────────────┐ │           ▼
     │  │ 1. JAKECreator      │ │   ┌──────────────────┐
     │  │ 2. JAKEChatter      │ │   │  Vector Store    │
     │  │ 3. JAKEChecker      │ │   │  (ChromaDB)      │
     │  │ 4. JAKEDynamicProfiler│   │  - Embeddings    │
     │  │ 5. JAKESummarizer   │ │   │  - Semantic      │
     │  └─────────────────────┘ │   │    Search        │
     └──────────────────────────┘   └──────────────────┘
```

---

## Documentation Files

- **PLAN.md** - Detailed process flow and architecture
- **CHATTING_FLOW.md** - Mermaid diagram of conversation pipeline
- **PROMPT_MANAGEMENT.md** - Guide for managing prompts
- **README.md** - Setup and quick start guide

---

## Testing

**Test Suite**: `test_jake.py`

Tests all components independently and the full orchestrator:
1. Character creation
2. Conversation generation
3. Quest checking
4. Memory extraction
5. Full orchestrator pipeline

**Run tests**:
```bash
python test_jake.py
```

